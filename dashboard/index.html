<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>FlowBoard — Project Management for OpenClaw</title>
  <link rel="icon" type="image/svg+xml" href="./favicon.svg">
  <link rel="icon" type="image/png" sizes="32x32" href="./favicon-32.png">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="./styles/dashboard.css?v=3">
  <!-- Telegram WebApp SDK (loads tg object, also used for graceful degradation check) -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
</head>
<body>
<script>
  // Graceful Degradation — client-side check before app loads
  // If opened outside Telegram AND no session cookie → show info page
  const _tg = window.Telegram?.WebApp;
  const _isLocal = ['localhost', '127.0.0.1'].includes(window.location.hostname);
  if (!_isLocal && (!_tg || !_tg.initData)) {
    document.addEventListener('DOMContentLoaded', () => {
      document.body.innerHTML = `
        <div style="font-family:sans-serif;text-align:center;padding:60px 20px;max-width:400px;margin:0 auto">
          <img src="./favicon.svg" style="width:64px;margin-bottom:16px" alt="FlowBoard">
          <h2 style="margin:0 0 8px">FlowBoard</h2>
          <p style="color:#888;margin:0 0 24px">Please open via Telegram.</p>
          <p style="color:#aaa;font-size:14px">Open this dashboard from your Telegram bot.</p>
        </div>`;
    });
  }
</script>

<div class="app" id="app">
  <div class="sidebar-backdrop" onclick="document.getElementById('app').classList.add('sidebar-collapsed')"></div>
  <div class="header">
    <div class="header-left">
      <button class="sidebar-toggle" onclick="toggleSidebar()" title="Toggle sidebar">☰</button>
      <span class="header-logo"><img src="./favicon.svg" alt="FlowBoard"></span>
      <div class="header-brand">
        <div class="header-title">FlowBoard</div>
        <div class="header-subtitle">Project Management</div>
      </div>
    </div>
    <div class="header-right" id="headerRight"></div>
  </div>

  <div class="tab-bar" id="tabBar">
    <button class="tab active" data-tab="tasks" onclick="switchTab('tasks')">Tasks</button>
    <button class="tab" data-tab="files" onclick="switchTab('files')">Files</button>
    <span class="tab-bar-spacer"></span>
    <span id="tabBarRight"></span>
  </div>

  <div class="sidebar" id="sidebar">
    <div class="sidebar-label">Projects</div>
    <div id="projectList"></div>
    <div class="sidebar-actions" id="sidebarActions"></div>
  </div>

  <div class="content" id="content"></div>

  <div class="footer">
    Auto-refresh active · Last update: <span id="lastRefresh">—</span>
  </div>
</div>

<div class="toast-container" id="toastContainer"></div>
<div id="modalRoot"></div>

<script type="module">
import { api, toast, showModal, escHtml, formatDisplayName, registerDisplayNames, updateTimestamp } from './js/utils.js?v=3';
import { 
  kanbanState, buildBoard, updateBoard, toggleSort, startAdd, cancelAdd, selectPriority, 
  onAddKey, createTask, startEdit, onTitleKey, saveTitle, togglePriorityPopover, setPriority,
  startDelete, confirmDelete, createSpec, onDragStart, onDragEnd, onDragOver, onDragLeave, onDrop,
  renderTabBarRight
} from './js/kanban.js?v=3';
import {
  fileState, loadFileTree, loadFileContent, saveFileContent, toggleFileEdit, toggleDir, fileBackToTree,
  renderFileExplorer, renderFileTree, applyStaticScrollbars, updateContentScrollbarVisibility
} from './js/file-explorer.js?v=5';

// Global state
const state = {
  projects: [],
  activeProject: null,
  viewedProject: null,
  tasks: [],
  currentTab: 'tasks'
};

// Make state accessible to modules
window.appState = state;

let prevProjectsJson = '';
let prevTasksJson = '';
let prevActiveProject = null;
let prevFilesMeta = null; // flat [{path, mtime, size}] for change detection

// Extract flat file fingerprint from a file tree for diffing
function getFilesMeta(tree) {
  const files = [];
  function walk(entries) {
    for (const e of entries) {
      if (e.type === 'file') files.push({ path: e.path, mtime: e.modified, size: e.size });
      if (e.children) walk(e.children);
    }
  }
  walk(tree || []);
  return files.sort((a, b) => a.path.localeCompare(b.path));
}

// --- Sidebar toggle ---
window.toggleSidebar = function() {
  document.getElementById('app').classList.toggle('sidebar-collapsed');
  window.Telegram?.WebApp?.HapticFeedback?.impactOccurred('light');
};

// --- Render functions ---
function renderSidebar() {
  const list = document.getElementById('projectList');
  if (state.projects.length === 0) {
    list.innerHTML = '<div class="sidebar-empty">No projects</div>';
  } else {
    list.innerHTML = state.projects.map(p => {
      const isActive = p.name === state.activeProject;
      const isViewed = p.name === state.viewedProject;
      const openCount = (p.taskCounts.open || 0) + (p.taskCounts['in-progress'] || 0);
      let cls = 'project-item';
      if (isActive) cls += ' agent-active';
      if (isViewed) cls += ' viewed';
      return `<div class="${cls}" onclick="viewProject('${p.name}')">
        <span>${formatDisplayName(p.name)}</span>
        ${openCount > 0 ? `<span class="project-badge">${openCount}</span>` : ''}
      </div>`;
    }).join('');
  }

  const actions = document.getElementById('sidebarActions');
  if (state.viewedProject && state.viewedProject !== state.activeProject) {
    actions.innerHTML = `<button class="btn btn-primary btn-sm btn-full" onclick="activateProject()">Activate</button>`;
  } else if (state.viewedProject && state.viewedProject === state.activeProject) {
    actions.innerHTML = `<button class="btn btn-secondary btn-sm btn-full" onclick="deactivateProject()">Deactivate</button>`;
  } else {
    actions.innerHTML = '';
  }
}

function renderHeader() {
  const el = document.getElementById('headerRight');
  if (!state.viewedProject) { el.innerHTML = ''; return; }
  const isActive = state.viewedProject === state.activeProject;
  el.innerHTML = `
    <span class="header-project">${formatDisplayName(state.viewedProject)}</span>
    ${isActive ? '<span class="badge-active">Active</span>' : ''}
  `;
}

function renderAll() {
  renderSidebar();
  const app = document.querySelector('.app');
  app.setAttribute('data-view', state.currentTab);
  renderHeader();
  if (state.currentTab === 'tasks') {
    renderTabBarRight();
    updateBoard(state);
  } else if (state.currentTab === 'files') {
    document.getElementById('tabBarRight').innerHTML = '';
    renderFileExplorer(state);
  }
  updateTimestamp();
  requestAnimationFrame(applyStaticScrollbars);
}

// --- Actions ---
window.viewProject = async function(name) {
  state.viewedProject = name;
  kanbanState.addingTask = false;
  kanbanState.editingTaskId = null;
  kanbanState.boardBuilt = false;
  fileState.fileTree = null;
  fileState.selectedFile = null;
  fileState.fileContent = null;
  prevFilesMeta = null; // Reset so next refresh re-baselines for new project
  const data = await api(`/projects/${name}/tasks`);
  state.tasks = data.tasks || [];
  prevTasksJson = JSON.stringify(state.tasks);
  renderAll();
};

window.activateProject = async function() {
  await api('/status', { method: 'PUT', body: { project: state.viewedProject } });
  state.activeProject = state.viewedProject;
  toast(`Project "${state.viewedProject}" activated`, 'success');
  renderSidebar();
  renderHeader();
};

window.deactivateProject = async function() {
  await api('/status', { method: 'PUT', body: { project: null } });
  state.activeProject = null;
  toast('Project deactivated.', 'info');
  renderSidebar();
  renderHeader();
};

// --- Tab System ---
window.switchTab = function(tab) {
  state.currentTab = tab;
  document.querySelectorAll('.tab').forEach(t => {
    t.classList.toggle('active', t.dataset.tab === tab);
  });
  if (tab === 'tasks') {
    kanbanState.boardBuilt = false;
    renderTabBarRight();
    updateBoard(state);
  } else if (tab === 'files') {
    document.getElementById('tabBarRight').innerHTML = '';
    renderFileExplorer(state);
  }
  requestAnimationFrame(updateContentScrollbarVisibility);
};

// --- Kanban Actions (exposed to window for inline handlers) ---
window.toggleSort = function() {
  if (toggleSort()) {
    kanbanState.boardBuilt = false;
    updateBoard(state);
  }
};
window.startAdd = function() { if (startAdd()) updateBoard(state); };
window.cancelAdd = function() { if (cancelAdd()) updateBoard(state); };
window.selectPriority = selectPriority;
window.onAddKey = function(e) {
  const action = onAddKey(e);
  if (action === 'create') createTask(state).then(changed => { if (changed) { prevTasksJson = JSON.stringify(state.tasks); updateBoard(state); } });
  if (action === 'cancel') { cancelAdd(); updateBoard(state); }
};
window.createTask = function() {
  createTask(state).then(changed => {
    if (changed) {
      prevTasksJson = JSON.stringify(state.tasks);
      updateBoard(state);
    }
  });
};
window.startEdit = startEdit;
window.onTitleKey = onTitleKey;
window.saveTitle = function(id, el) {
  saveTitle(id, el, state).then(() => {
    prevTasksJson = JSON.stringify(state.tasks);
  });
};
window.togglePriorityPopover = togglePriorityPopover;
window.setPriority = function(id, priority) {
  setPriority(id, priority, state);
  prevTasksJson = JSON.stringify(state.tasks);
};
window.startDelete = startDelete;
window.confirmDelete = function(id) {
  confirmDelete(id, state).then(changed => {
    if (changed) {
      prevTasksJson = JSON.stringify(state.tasks);
      updateBoard(state);
    }
  });
};

// Drag & Drop
window.onDragStart = onDragStart;
window.onDragEnd = onDragEnd;
window.onDragOver = onDragOver;
window.onDragLeave = onDragLeave;
window.onDrop = function(e) { onDrop(e, state); };

// --- Spec File Actions ---
window.openSpec = function(specPath, taskId) {
  if (!specPath) {
    toast(`No spec linked${taskId ? ` for ${taskId}` : ''}`, 'warn');
    return;
  }
  window.switchTab('files');
  setTimeout(() => loadFileContent(specPath, state), 100);
};
window.createSpec = function(taskId) {
  createSpec(taskId, state).then(specFile => {
    if (specFile) {
      prevTasksJson = JSON.stringify(state.tasks);
      updateBoard(state);
      window.switchTab('files');
      setTimeout(() => loadFileContent(specFile, state), 100);
    }
  });
};

// --- File Explorer Actions ---
window.loadFileContent = function(path) { loadFileContent(path, state); };
window.saveFileContent = function() { saveFileContent(state); };
window.toggleFileEdit = toggleFileEdit;
window.toggleDir = toggleDir;
window.fileBackToTree = fileBackToTree;
window.deleteCurrentFile = function() {
  const filePath = fileState?.selectedFile;
  if (!filePath) return;
  showModal('Delete File', `Delete <strong>${filePath}</strong>?`, async () => {
    try {
      const res = await fetch(`/api/projects/${state.activeProject}/files/${filePath}`, { method: 'DELETE' });
      const data = await res.json();
      if (!res.ok) { toast(data.error || 'Delete failed', 'error'); return; }
      toast(`Deleted ${filePath}`, 'success');
      fileBackToTree();
    } catch (err) { toast('Delete failed: ' + err.message, 'error'); }
  });
};

// --- User Interaction Detection ---
function isUserInteracting() {
  if (kanbanState.addingTask || kanbanState.editingTaskId) return true;
  if (document.getElementById('modalOverlay')) return true;
  const active = document.activeElement;
  return active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA');
}

// --- Smart refresh ---
async function refresh() {
  try {
    const data = await api('/projects');
    const newProjects = data.projects || [];
    const newActive = data.activeProject;
    const projectsJson = JSON.stringify(newProjects);
    const projectsChanged = projectsJson !== prevProjectsJson || newActive !== prevActiveProject;

    state.projects = newProjects;
    registerDisplayNames(newProjects);
    state.activeProject = newActive;
    prevProjectsJson = projectsJson;
    prevActiveProject = newActive;

    if (!state.viewedProject) {
      if (state.activeProject) state.viewedProject = state.activeProject;
      else if (state.projects.length > 0) state.viewedProject = state.projects[0].name;
    }

    let tasksChanged = false;
    if (state.viewedProject) {
      const taskData = await api(`/projects/${state.viewedProject}/tasks`);
      const newTasks = taskData.tasks || [];
      const tasksJson = JSON.stringify(newTasks);
      if (tasksJson !== prevTasksJson) {
        tasksChanged = true;
        state.tasks = newTasks;
        prevTasksJson = tasksJson;
      }
    }

    // --- File tree polling (always, silent update; render only when on files tab) ---
    let filesChanged = false;
    let changedFilePath = null;
    if (state.viewedProject) {
      try {
        const filesData = await api(`/projects/${state.viewedProject}/files`);
        const newMeta = getFilesMeta(filesData.tree);
        const newMetaJson = JSON.stringify(newMeta);
        const prevMetaJson = JSON.stringify(prevFilesMeta);
        if (newMetaJson !== prevMetaJson) {
          filesChanged = true;
          // Detect if the currently open file changed
          if (fileState.selectedFile && prevFilesMeta) {
            const prev = prevFilesMeta.find(f => f.path === fileState.selectedFile);
            const next = newMeta.find(f => f.path === fileState.selectedFile);
            if (next && (!prev || prev.mtime !== next.mtime)) changedFilePath = fileState.selectedFile;
          }
          prevFilesMeta = newMeta;
          fileState.fileTree = filesData; // Update silently (no extra fetch on tab switch)
        }
      } catch (e) { /* silent */ }
    }

    if (isUserInteracting() && !projectsChanged) {
      updateTimestamp();
      return;
    }

    if (projectsChanged) { renderSidebar(); renderHeader(); }
    if (tasksChanged && state.currentTab === 'tasks') { updateBoard(state); }

    if (filesChanged && state.currentTab === 'files') {
      renderFileTree(); // Diff-update tree (new/deleted/renamed files appear instantly)

      // Selected file was deleted → auto-open first available file (same pattern as init)
      const selectedGone = fileState.selectedFile && !prevFilesMeta?.find(f => f.path === fileState.selectedFile);
      if (selectedGone) {
        fileState.selectedFile = null;
        fileState.fileContent = null;
        const firstFile = fileState.fileTree?.tree?.find(e => e.type === 'file');
        if (firstFile) loadFileContent(firstFile.path, state);
      } else if (changedFilePath && !fileState.fileEditing) {
        // Reload content if open file changed and not currently editing
        loadFileContent(changedFilePath, state);
      }
    }

    updateTimestamp();
  } catch (err) {
    console.error('Refresh error:', err);
  }
}

// --- Init ---
async function init() {
  const data = await api('/projects');
  state.projects = data.projects || [];
  registerDisplayNames(state.projects);
  state.activeProject = data.activeProject;
  prevProjectsJson = JSON.stringify(state.projects);
  prevActiveProject = state.activeProject;

  if (state.activeProject) state.viewedProject = state.activeProject;
  else if (state.projects.length > 0) state.viewedProject = state.projects[0].name;

  if (state.viewedProject) {
    const taskData = await api(`/projects/${state.viewedProject}/tasks`);
    state.tasks = taskData.tasks || [];
    prevTasksJson = JSON.stringify(state.tasks);

    // Initialize file meta baseline so first refresh doesn't false-positive
    try {
      const filesData = await api(`/projects/${state.viewedProject}/files`);
      fileState.fileTree = filesData;
      prevFilesMeta = getFilesMeta(filesData.tree);
    } catch (e) { /* silent */ }
  }

  renderAll();
  setInterval(refresh, 5000);
}

// Telegram WebApp integration
const tg = window.Telegram?.WebApp;

function haptic(type = 'light') {
  tg?.HapticFeedback?.impactOccurred(type);
}
function hapticNotification(type = 'success') {
  tg?.HapticFeedback?.notificationOccurred(type);
}

function applyTelegramTheme() {
  if (!tg?.themeParams) return;
  const { bg_color, text_color, hint_color, button_color, secondary_bg_color } = tg.themeParams;
  const r = document.documentElement;
  if (bg_color)           r.style.setProperty('--tg-bg', bg_color);
  if (text_color)         r.style.setProperty('--tg-text', text_color);
  if (hint_color)         r.style.setProperty('--tg-hint', hint_color);
  if (button_color)       r.style.setProperty('--tg-btn', button_color);
  if (secondary_bg_color) r.style.setProperty('--tg-secondary-bg', secondary_bg_color);
}

// Viewport height now handled by pure CSS (100dvh) — no JS override needed
// Telegram's viewportStableHeight caused collapse on minimize/resume

// External links via Telegram
document.addEventListener('click', e => {
  const link = e.target.closest('a[href]');
  if (!link) return;
  const href = link.href;
  if (tg && href.startsWith('http') && !href.includes(window.location.hostname)) {
    e.preventDefault();
    tg.openLink(href);
  }
});

// Telegram WebApp Auth + init
(async () => {
  if (tg?.initData) {
    tg.ready();
    tg.expand();
    tg.disableVerticalSwipes?.();
    applyTelegramTheme();
    tg.onEvent?.('themeChanged', applyTelegramTheme);
    try {
      await fetch('/api/auth', {
        method: 'POST',
        headers: { 'X-Telegram-Init-Data': tg.initData }
      });
    } catch (e) { console.warn('Auth failed:', e); }
  }
  await init();
})();
</script>
</body>
</html>
